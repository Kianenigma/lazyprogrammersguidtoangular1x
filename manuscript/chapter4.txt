
# Controllers, templates and more!
In the previous chapter, although we learned some very good fundamental details of Angular (specially on controllers and `$scope`) , but the code that we worked on was mostly like a *Hello World* for Angular. 
In this chapter we will learn more technical details of Angular. by technical I mean that they are going to be details that you surely will need to know them and use them in your next Angular project! 

The code for this chapter can be found under a separate folder under the [github repository](https://github.com/Kianenigma/lazyprogrammersguidtoangular1x/tree/master/code/chapter4) associated with this project.

As a *heads up* for this chapter, it is good to mention that we are going to learn a LOT in this chapter. and as the name suggests, they are all going to be implemented inside and using a controller. in the next chapter we are going to dedicate our time to revisit all that we learn here to see which of them are suited to be implemented via a **Service** or a **Directive** so they become **Reusable components**.

We are going to start with a single page application with an `index.html` and `main.js` file linked like the previous chapter. I also included twitter bootstrap to make the pages that we create a little bit brighter! if you are not familiar with it, it's just library that you can use a set of css classes it provides to have a better looking HTML. 

## More advance iteration with ng-repeat and pipe filters

In the previous chapter we barely introduced `ng-repeat`, while one of the most commonly used angular directives. Let's inspect it more and see how it behaves with objects instead of arrays, and how to mix it up with some filters. 

### ng-repeat with objects

You now know how to iterate a simple array. Two more things to learn: 

 1. Iterating over objects
 2. Iterating over arrays of objects

We'll change our list of actor to the following: 

```javascript 
$scope.actors = {
    "Ted": { lastName: "Mosbey", age: 27 },
    "Barney": { lastName: "Stinson", age: 30 }
  }
```

If you iterate over this object with the same way as we did before, you'll find something like this: 

```html
	<li class="list-group-item">
		{ lastName: "Mosbey", age: 27 }
	</li>
	<li class="list-group-item">
		{ lastName: "Stinson", age: 30 }
	</li>
	...
```

We have no access to the `key` of the object and the values are displayed as plaing object.

Two point will solve this: 

**First**, you can use `ng-repeat="for (key, value) in someObject"` to have access to both the keys and both the values. 

**Second**, you should know that Angular's template syntax actually supports a large subset of javascript operation, like : `{{ a + b }}`, `{{ someFunction(someProp) }}`, `{{ someString + ' , I am concatenated! }}'`, so you can use the **dot operation** to access the properties the object associated with a key. Change the html template: 

```html
<li class="list-group-item" ng-repeat="(name, detail) in actors">
	{{ name }} [{{detail.lastName}}] is {{ detail.age }} years old!
</li>
``` 

Having this in mind you can even figure out how you can have nested loops. change to `actors` property to:

```javascript
$scope.actors = {
    "Ted": {
      lastName: "Mosbey",
      age: 27,
      bars: ["Blind Tiger", "Torst", "Good Beer"]
    },
    "Barney": {
      lastName: "Stinson",
      age: 30,
      bars: ["The Poney Bar"]
    }
  }
```

And your HTML to: 

```html
<li class="list-group-item" ng-repeat="(name, detail) in actors">
          {{ name }} [{{detail.lastName}}] is {{ detail.age }} years old!
          I like catching a beer in
          <span ng-repeat="bar in detail.bars"> {{ bar }} , </span>
</li>
```

There is a problem here! We really don't want the last `,` there. Let's use some template magic to get rid of it:

```html
<span ng-repeat="bar in detail.bars">
      {{ bar }} {{ ($index === ( $parent.detail.bars.length-1 ) ) ? '' : ',' }} 
</span>
```

As you see, we used an if statement to check the index of the bar being printed, with the length of all of the bars, and when we reach the last one, we omit the `,`

You should know clearly why `$parent.detail.bar` is what we compared it's length with `$index` (nested loops! each creating their own scopes!) , if you don't, jump right back to the section about `ng-repeat` in chapter 3!


### Filters

Filters provide a way to modify any model binding in your html. By the Term model binding I mean any place that you place one your $scope properties inside HTML. It could be:

 - Template binding `{{ someModel }}`
 - Loops `<div ng-repeat="item in someModel">` 

Or any other place. The filters work similar to Unix pipe style. think of your model as the input and with each `|`operator it will be piped into a filter and the results come out. with this way, multiple pipes can be combined and the output of one of them could be added to the other one. 

Like many other situations, Angular provides us with a set of built in filters, but with can extend them to any usage and build our own filter. you can read the full list of filters here[enter link description here](https://docs.angularjs.org/guide/filter). 

Let's begin testing with some of the built in filters. one of these filters are called `uppercase` and you probably guess from the name what it is going to do! Apply it to the list of beers from the previous section with: 

```html
<span ng-repeat="bar in detail.bars">
  {{ bar | uppercase }} {{ ($index === ($parent.detail.bars.length-1)) ? '' : 'or' }}
</span>
```

Notice the `|` pipe after `{{ bar }}`. Aside from simple filters like `uppercase` that works on a single object, there are some more interesting filters that work on collection, arrays, and can be applied to loops. 

One of the best filters for collections is called... well, it's called `filter`! It works only on arrays and takes an argument as input and returns only those elements in the array that contain the value given. 

Modify the following for an actor's list of favorite beer.

```html
<li class="list-group-item" ng-repeat="(name, detail) in actors">
     {{ name }} [{{detail.lastName}}] is {{ detail.age }} years old! I like catching a beer in
     <input type="text" ng-model="beerFilter" />
     <span ng-repeat="bar in detail.bars | filter : beerFilter">
             {{ bar | uppercase }} {{ ($index === ($parent.detail.bars.length-1)) ? '' : 'or' }}
     </span>
</li>
```

Change the value inside the `input` tag you see that the array of beers will actually get filtered according to that value. As mentioned before, the fact that we never declared `$scope.beerFilter` is not a problem. It will be equal to undefined at the beginning and will have a value as we modify the `input` tag. 

The `orderBy` filter works over an array of objects by taking one key name as the filter and sorting the array according to that key. For example: `<div ng-repeat="item in array | orderBy 'keyName'"> ... </div>` will sort an array with the format 

```javascript 
$scope.array = [
	{name: "item1", key:3},
	{name: "item2", key:2},
	{name: "item3", key:1}
[
```

according to `key` property.

Let's finish this section with creating a custom filter. Custom filters can be created using the `.filter()` method on a module. it must return o function that takes the input value as argument and returns the new formatted values as output.

The following filter simply takes an string input and returns the same value in reverse. 

```javascript
myApp.filter('strRev', function () {
  return function (inp) {
    return inp.split('').reverse().join('')
  }
})
``` 

You can now test it with : 

```html
<span ng-repeat="bar in detail.bars | filter : beerFilter">
      {{ bar | strRev }} {{ ($index === ($parent.detail.bars.length-1)) ? '' : 'or' }}
</span>
```

As you might have noticed, we have two types of filters, those who operate on single values (pipe) and those who filter a collection. Creating a custom filter that operates on a collection has the same API and routine as above, but it takes additional input arguments beside `inp`. As a good exercise, you can go ahead and read some examples of this type of filter and work on creating the following the filters : 

 - One that filters an object over it key names.
 - One that takes an array and returns all of its elements in `uppercase` format. 

----------


## Style manipulation with Angular

Angular provides convenient ways to manipulate the DOM attributes or Style. Some of these ways will be described in this section. the key difference between Angular's way and vanilla Javascript's way is that using Angular, as you might expect, we can control element's style and behavior using `$scope` properties, which gives us a better and easier way of control.   

### Using ng-show, ng-hide and ng-if
Two of the most basic of these UI controls are two directives named: ng-show and ng-hide. as the names suggest, they both hide or show an element based on the expression given to it. Look at the following example: 

```html
<div class="row">
     <div class="col col-sm-6 col-sm-offset-3">
        <button class="btn btn-success btn-block" ng-show="true">
            Click me for some process
        </button>
     </div>
</div>
```

As you see, the button is there. now change the `ng-show` value to `false`. As you might expect, the button goes away. Now browse the DOM elements with your browser. As you find the button node, you'll see that it has been rendered as: 

```html
<button class="btn btn-success btn-block ng-hide" ng-show="true">
      Click me for some process
</button>
```

The `ng-hide` class automatically adds the `display: none` property to the node element. There are some important notes to keep in mind about `display: none` here: 

 - This property will hide all of the child elements
 - ng-hide **will not cause the DOM elements to be not rendered**, it just hides them. 

The `ng-hide` works exactly in the same manner, but as the name suggests, the Boolean value *is the other way around* and when it is equal to `false`, the element will not be displayed. 

The ng-if directive works almost the same as ng-show, but there is one key difference, if the expression provided to `ng-if` is equal to `false`, the element will actually be **removed** from the DOM, and if later evaluates to `true` again, it will be **recreated** once again. 

We mentioned : 

> the key difference between Angular's way and vanilla Javascript's way is that using Angular, as you might expect, we can control element's style and behavior using `$scope` properties, which gives us a better and easier way of control.   

But so far, even though we learned how ng-show, `ng-hide` and `ng-if` work, we only used static `true / false` values for testing. let's try this in a more realistic way and use `$scope` properties to control the button: 

Suppose that the button will perform an http request as you click it and you wish for it to display a loading icon during this period and then fade away.

We add to state variables to our scope, indicating weather the button or the icon should be displayed or not, and a function to change them.

```javascript
$scope.btnDisplay = true;
$scope.iconDisplay = false;

$scope.doProcess = function () {
  $scope.iconDisplay = true;
  $timeout(function () { $scope.btnDisplay = false }, 3000);
}
```  

And then just assign these values to the HTML markup that we had: 

```html
<button ng-click="doProcess()" ng-if="btnDisplay" class="btn btn-success btn-block">
            <span 
	        ng-show="iconDisplay" 
	        class="glyphicon glyphicon-cloud-download">
	        </span> 
	        {{ iconDisplay ? 'Waiting for process' : 'Click me for some process'}}
</button>
```

### Using ng-class 


----------


## Ups and down of form management with angular


----------


## Using $http and $watch 


----------


## Controller events and communication 


----------


## The great $rootScope 


